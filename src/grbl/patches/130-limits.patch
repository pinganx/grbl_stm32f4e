--- grbl-master/limits.c	2014-03-16 21:48:30.000000000 -0700
+++ grbl-master/limits.c	2014-03-16 21:49:55.000000000 -0700
@@ -34,6 +34,7 @@
 
 void limits_init() 
 {
+#if 0
   LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
   #ifndef LIMIT_SWITCHES_ACTIVE_HIGH
     LIMIT_PORT |= (LIMIT_MASK); // Enable internal pull-up resistors. Normal high operation.
@@ -47,8 +48,10 @@
     LIMIT_PCMSK &= ~LIMIT_MASK; // Disable
     PCICR &= ~(1 << LIMIT_INT); 
   }
+#endif
 }
 
+#if 0
 // This is the Limit Pin Change Interrupt, which handles the hard limit feature. A bouncing 
 // limit switch can cause a lot of problems, like false readings and multiple interrupt calls.
 // If a switch is triggered at all, something bad has happened and treat it as such, regardless
@@ -78,6 +81,7 @@
     }
   }
 }
+#endif
 
 
 // Moves all specified axes in same specified direction (positive=true, negative=false)
@@ -141,12 +145,14 @@
   uint32_t dt_min = lround(1000000*60/(ds*homing_rate)); // Cruising (usec/step)
   uint32_t dt = 1000000*60/MINIMUM_STEPS_PER_MINUTE; // Initial (usec/step)
   if (dt > dt_min) { dt = dt_min; } // Disable acceleration for very slow rates.
-      
+     
+#if 0 
   // Set default out_bits. 
   uint8_t out_bits0 = settings.invert_mask;
   out_bits0 ^= (settings.homing_dir_mask & DIRECTION_MASK); // Apply homing direction settings
   if (!pos_dir) { out_bits0 ^= DIRECTION_MASK; }   // Invert bits, if negative dir.
-  
+#endif 
+ 
   // Initialize stepping variables
   int32_t counter_x = -(step_event_count >> 1); // Bresenham counters
   int32_t counter_y = counter_x;
@@ -157,14 +163,16 @@
   uint8_t out_bits;
   uint8_t limit_state;
   for(;;) {
-  
+ 
+#if 0 
     // Reset out bits. Both direction and step pins appropriately inverted and set.
     out_bits = out_bits0;
     
     // Get limit pin state.
     limit_state = LIMIT_PIN;
     if (invert_pin) { limit_state ^= LIMIT_MASK; } // If leaving switch, invert to move.
-    
+#endif   
+ 
     // Set step pins by Bresenham line algorithm. If limit switch reached, disable and
     // flag for completion.
     if (cycle_mask & (1<<X_AXIS)) {
@@ -194,13 +202,15 @@
     
     // Check if we are done or for system abort
     if (!(cycle_mask) || (sys.execute & EXEC_RESET)) { return; }
-        
+     
+#if 0   
     // Perform step.
     STEPPING_PORT = (STEPPING_PORT & ~STEP_MASK) | (out_bits & STEP_MASK);
     delay_us(settings.pulse_microseconds);
     STEPPING_PORT = out_bits0;
     delay_us(step_delay);
-    
+#endif   
+ 
     // Track and set the next step delay, if required. This routine uses another Bresenham
     // line algorithm to follow the constant acceleration line in the velocity and time 
     // domain. This is a lite version of the same routine used in the main stepper program.
